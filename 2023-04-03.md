- ServerSocket은 accept 메소드를 호출할 때 새로운 커넥션이 맺어지면서 Socket 인스턴스를 반환할때까지 blocked. 다시 말해 다른 밀려드는 요청을 받아들일 수 없는 상태가 됨.
- 고전적인 소켓 프로그래밍은 한 번에 하나의 커넥션만 처리할 수 있기때문에 동시성을 확보하기위해서는 소켓마다 쓰레드를 할당해야 함 -> 하지만 쓰레드도 갯수 제한이 있지
- 이런 blocking io가 왜 문제가 되냐?
    - input, output을 기다리는 잠자는 쓰레드가 생길 수 있음
    - 쓰레드당는 스택이 필요한 데 하나의 쓰레드당 스택 할당에 메모리를 64kb에서 1mb까지 사용함 os마다 다름
    - 10,000 커넥션이 한계일거임
    - 컨텍스트 스위칭마다 cpu는 미친듯이 올라가겠지
- 그래서 Nio가 나옴 얘는 리소스 효율성을 높이기 위해 나온듯
    - selector가 지금 io 할 준비된 socket을 선택하는듯
    - 그러면 thread 하나가 io를 처리하기 위해 나타남
    - 소켓을 받아들이는 부분과 실제로 io를 담당하는 부분을 분리해서 더이상 쓰레드가 놀일이 없게 한듯
    - 커넥션이 없어서 소켓이 없으면 쓰레드는 아예 다른일을 할수도 있음
    - 하지만 여전히 안정적인 고효용성 네트워킹 시스템을 만드는건 쉽지 않았음 그래서 네티 탄생
    - input/output할 때까지 기다릴 필요 없이 사용자는 요청만 하고 실제로 언제 작업이 완료되었는지 notification api로 알려줌



